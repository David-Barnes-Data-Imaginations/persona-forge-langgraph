<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Voice Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        #log {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px 5px;
            cursor: pointer;
        }
        #recordBtn {
            background: #4CAF50;
            color: white;
            border: none;
        }
        #recordBtn.recording {
            background: #f44336;
        }
        .log-entry {
            margin: 5px 0;
            padding: 3px;
        }
        .log-info { color: #2196F3; }
        .log-success { color: #4CAF50; }
        .log-error { color: #f44336; }
        .log-warning { color: #FF9800; }
    </style>
</head>
<body>
    <h1>ðŸŽ¤ WebSocket Voice Test</h1>
    <p>This test will help debug the voice connection.</p>
    
    <div>
        <button id="recordBtn">ðŸŽ¤ Start Recording</button>
        <span id="status">Ready</span>
    </div>
    
    <h3>Debug Log:</h3>
    <div id="log"></div>
    
    <script>
        const logDiv = document.getElementById('log');
        const recordBtn = document.getElementById('recordBtn');
        const statusSpan = document.getElementById('status');
        
        let ws = null;
        let audioContext = null;
        let processor = null;
        let stream = null;
        let isRecording = false;
        let chunkCount = 0;
        
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        recordBtn.addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });
        
        async function startRecording() {
            try {
                log('ðŸ”Œ Connecting to WebSocket...', 'info');
                statusSpan.textContent = 'Connecting...';
                
                const backendUrl = 'http://localhost:8001';
                const wsUrl = backendUrl.replace(/^http/, 'ws');
                ws = new WebSocket(`${wsUrl}/ws/vad-stream`);
                
                log(`ðŸ“¡ WebSocket URL: ${wsUrl}/ws/vad-stream`, 'info');
                
                ws.onopen = async () => {
                    log('âœ… WebSocket connected!', 'success');
                    statusSpan.textContent = 'Connected - Getting microphone...';
                    
                    try {
                        // Get microphone
                        log('ðŸŽ¤ Requesting microphone access...', 'info');
                        stream = await navigator.mediaDevices.getUserMedia({
                            audio: {
                                channelCount: 1,
                                sampleRate: 16000,
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true,
                            }
                        });
                        
                        log('âœ… Microphone access granted!', 'success');
                        
                        // Create audio context
                        audioContext = new AudioContext({ sampleRate: 16000 });
                        const source = audioContext.createMediaStreamSource(stream);
                        processor = audioContext.createScriptProcessor(4096, 1, 1);
                        
                        chunkCount = 0;
                        
                        processor.onaudioprocess = (e) => {
                            if (ws.readyState === WebSocket.OPEN) {
                                const inputData = e.inputBuffer.getChannelData(0);
                                
                                // Convert float32 to int16 PCM
                                const pcmData = new Int16Array(inputData.length);
                                for (let i = 0; i < inputData.length; i++) {
                                    const s = Math.max(-1, Math.min(1, inputData[i]));
                                    pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                                }
                                
                                // Send raw PCM data
                                ws.send(pcmData.buffer);
                                chunkCount++;
                                
                                if (chunkCount % 50 === 0) {
                                    log(`ðŸ“¦ Sent ${chunkCount} audio chunks`, 'info');
                                }
                            }
                        };
                        
                        source.connect(processor);
                        processor.connect(audioContext.destination);
                        
                        isRecording = true;
                        recordBtn.classList.add('recording');
                        recordBtn.textContent = 'ðŸ›‘ Stop Recording';
                        statusSpan.textContent = 'Recording...';
                        log('ðŸŽ™ï¸ Recording started!', 'success');
                        
                    } catch (error) {
                        log(`âŒ Microphone error: ${error.message}`, 'error');
                        statusSpan.textContent = 'Microphone denied';
                        ws.close();
                    }
                };
                
                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        log(`ðŸ“¨ Received: ${JSON.stringify(message)}`, 'success');
                        
                        if (message.type === 'TRANSCRIPT' && message.text) {
                            log(`ðŸ“ TRANSCRIPT: "${message.text}"`, 'success');
                            statusSpan.textContent = `Transcribed: ${message.text}`;
                            // Close WebSocket after receiving transcript
                            setTimeout(() => {
                                if (ws) {
                                    log('âœ… Closing WebSocket after successful transcription', 'success');
                                    ws.close();
                                }
                            }, 100);
                        } else if (message.type === 'ERROR') {
                            log(`âŒ ERROR: ${message.message}`, 'error');
                            if (ws) ws.close();
                        } else if (message.type === 'STATUS') {
                            log(`â„¹ï¸ STATUS: ${message.message}`, 'warning');
                            if (ws) ws.close();
                        }
                    } catch (error) {
                        log(`âŒ Message parse error: ${error.message}`, 'error');
                    }
                };
                
                ws.onclose = () => {
                    log('ðŸ”Œ WebSocket closed', 'warning');
                    cleanup();
                };
                
                ws.onerror = (error) => {
                    log(`âŒ WebSocket error: ${error}`, 'error');
                    statusSpan.textContent = 'Connection error';
                    cleanup();
                };
                
            } catch (error) {
                log(`âŒ Start recording error: ${error.message}`, 'error');
                statusSpan.textContent = 'Failed';
            }
        }
        
        function stopRecording() {
            log('ðŸ›‘ Stopping recording...', 'info');
            statusSpan.textContent = 'Processing...';
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                const endMessage = JSON.stringify({ type: "UTTERANCE_END" });
                log(`ðŸ“¤ Sending UTTERANCE_END (sent ${chunkCount} total chunks)`, 'info');
                log('â³ Waiting for transcription response (keeping WebSocket open)...', 'info');
                ws.send(endMessage);
                
                // DON'T close immediately - wait for response!
                // The onmessage handler will receive the transcript
                // Set a timeout in case backend doesn't respond
                setTimeout(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        log('â° Timeout waiting for response, closing WebSocket...', 'warning');
                        ws.close();
                    }
                }, 30000);  // 30 second timeout
            } else {
                log(`âŒ Cannot send UTTERANCE_END - socket state: ${ws?.readyState}`, 'error');
                cleanup();
            }
            
            // Stop audio capture but keep WebSocket open
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
        }
        
        function cleanup() {
            if (processor) {
                processor.disconnect();
                processor = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            isRecording = false;
            recordBtn.classList.remove('recording');
            recordBtn.textContent = 'ðŸŽ¤ Start Recording';
            statusSpan.textContent = 'Ready';
            log('ðŸ§¹ Cleaned up resources', 'info');
        }
    </script>
</body>
</html>
